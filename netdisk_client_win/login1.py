# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'login.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import socket
from PyQt5 import QtCore, QtGui, QtWidgets
import threading
import stopThreading
from PyQt5.QtWidgets import QMessageBox

DEBUG = 1
HOST = '139.224.198.253'
PORT = 8080
ADDR = (HOST, PORT)
ENCODING = 'gbk'
BUFFSIZE = 1024
def tcpClient():
    # 创建客户套接字
    with socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM) as s:
        # 尝试连接服务器
        s.connect(ADDR)
        print('连接服务成功！！')
        # 通信循环

        while True:
            input('pleace input something:')

            # 发送数据到服务器
            inData = '1'

            s.send(inData.encode(ENCODING))
            print('发送成功！')

            # 接收返回数据
            outData = s.recv(BUFFSIZE)
            print('返回数据信息：')
            print(format(outData))

        # 关闭客户端套接字
        s.close()
#test_str ="event=register\naccount=2205290\npasswd=1234456\n"



def socket_connect(self):
    self.s.connect(ADDR)
    print('已连接到服务器')

class Ui_LoginWin(object):
    def __init__(self):
        super(Ui_LoginWin, self).__init__()
        self.s = None  # s代表socket，本文件中为tcp socket
        self.s_th = None  # s_th代表 thread
        self.client_th = None
        self.accept_th = None
        self.client_socket_list = list()
        self.link = False  # 初始化连接状态为False
        self.working = False  # 初始化工作状态为False

    def setupUi(self, LoginWin):
        LoginWin.setObjectName("LoginWin")
        LoginWin.resize(701, 559)
        self.left = QtWidgets.QLabel(LoginWin)
        self.left.setGeometry(QtCore.QRect(90, 100, 231, 341))
        self.left.setStyleSheet("background-color: rgb(228, 255, 246);")
        self.left.setText("")
        self.left.setObjectName("left")
        self.right = QtWidgets.QLabel(LoginWin)
        self.right.setGeometry(QtCore.QRect(300, 100, 431, 341))
        self.right.setStyleSheet("background-image: url(:/images/2.jpg);")
        self.right.setObjectName("right")
        self.welcome = QtWidgets.QLabel(LoginWin)
        self.welcome.setGeometry(QtCore.QRect(120, 160, 151, 51))
        font = QtGui.QFont()
        font.setFamily("幼圆")
        font.setPointSize(20)
        self.welcome.setFont(font)
        self.welcome.setObjectName("welcome")
        self.user = QtWidgets.QLineEdit(LoginWin)
        self.user.setGeometry(QtCore.QRect(120, 240, 141, 21))
        self.user.setStyleSheet("border:none;\n"
"background-color: rgb(228, 255, 246);\n"
"border-bottom:2px solid rgba(0,0,0,100);")
        self.user.setObjectName("user")

        self.passwd = QtWidgets.QLineEdit(LoginWin)
        self.passwd.setGeometry(QtCore.QRect(120, 300, 141, 21))
        self.passwd.setStyleSheet("border:none;\n"
"background-color: rgb(228, 255, 246);\n"
"border-bottom:2px solid rgba(0,0,0,100);")
        self.passwd.setObjectName("passwd")

        #
        self.login = QtWidgets.QPushButton(LoginWin)
        self.login.setGeometry(QtCore.QRect(110, 370, 81, 41))
        self.login.setObjectName("login")

        #
        self.register_2 = QtWidgets.QPushButton(LoginWin)
        self.register_2.setGeometry(QtCore.QRect(200, 370, 81, 41))
        self.register_2.setObjectName("register_2")

        self.retranslateUi(LoginWin)
        QtCore.QMetaObject.connectSlotsByName(LoginWin)

######

##################




    def retranslateUi(self, LoginWin):
        _translate = QtCore.QCoreApplication.translate
        LoginWin.setWindowTitle(_translate("LoginWin", "Dialog"))
        self.right.setText(_translate("LoginWin", "TextLabel"))
        self.welcome.setText(_translate("LoginWin", "欢迎登录"))
        self.user.setPlaceholderText(_translate("LoginWin", "账号："))
        self.passwd.setPlaceholderText(_translate("LoginWin", "密码："))
        self.login.setText(_translate("LoginWin", "确定"))
        self.register_2.setText(_translate("LoginWin", "注册"))

        #self.socket_connect();
        self.login.clicked.connect(self.on_pushButton_login_clicked1)
        


    def socket_open_tcpc(self):
        """
        软件作为tcp client模式连接到其他tcp server
        :return:
        """
        self.open_btn.setEnabled(False)
        remote_ip = HOST
        remote_port = PORT
        ip_port = (remote_ip, int(remote_port))
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print('123')
        try:
            self.s.connect(ip_port)
        except Exception as ret:
            print("Error:", ret)
            QMessageBox.critical(self, '错误', str(ret))
            self.socket_close()
        else:
            self.working = True
            self.link = True  # 设置连接状态标志位 True
            self.client_th = threading.Thread(
                target=self.tcp_client_concurrency)
            # 设置线程为守护线程，防止退出主线程时，子线程仍在运行
            self.client_th.setDaemon(True)
            self.client_th.start()
            connect_info = "已连接到服务器IP: %s 端口: %s\n" % ip_port
            self.signal_add_clientstatus_info.emit(connect_info)

    def tcp_client_concurrency(self):
        """
        TCP客户端创建子线程，防止主线程GUI为响应造成崩溃
        :return:
        """
        while True:
            try:
                """
                    针对服务器主动断开的异常处理
                """
                recv_msg = self.s.recv(1024)
            except Exception as ret:
                print("Error:", ret)
                # 这里不能用QMessageBox，会导致崩溃
                # QMessageBox.critical(self, '错误', str(ret))
                self.socket_close()

            else:
                if recv_msg:
                    # 判断是否以16进制显示并处理
                    self.if_hex_show_tcpc_udp(recv_msg)
                    # 将接收到的数据字节数显示在状态栏的计数区域
                    self.rx_count += len(recv_msg)
                    self.statusbar_dict['rx'].setText('接收计数：%s' % self.rx_count)
                else:
                    self.s.close()
                    msg = '连接已断开\n'
                    self.signal_write_msg.emit(msg)
                    self.working = False
                    self.socket_close()
                    break

    def socket_close(self):
        """
        关闭TCP网络的方法
        :return:
        """
        self.clients_list.clear()
        # 当软件工作在TCPServer模式下
        self.prot_box.setEnabled(1)  # 使通信协议下拉框重新可选
        if self.prot_box.currentIndex() == 0:
            try:
                for client, address in self.client_socket_list:
                    # 关闭所有的conn
                    client.close()
                    # 从conn连接列表中移除每个conn，以防下次进入监听状态时conn列表不为空，影响data_send_t按钮的判断，
                    self.client_socket_list.remove((client, address))
                self.s.close()  # 关闭套接字
                self.working = False
                self.open_btn.setEnabled(True)
                print('server closed...')
            except Exception as ret:
                pass
        # 当软件工作在TCPClient模式下
        if self.prot_box.currentIndex() == 1:
            try:
                self.s.close()
                self.working = False
                self.open_btn.setEnabled(True)
                print('TCP connection closed...')
            except Exception as ret:
                pass

        try:
            # 关闭线程
            stopThreading.stop_thread(self.s_th)
            self.link = False
        except Exception:
            pass
        try:
            # 关闭线程
            stopThreading.stop_thread(self.client_th)
            self.link = False
        except Exception:
            pass

    def on_pushButton_login_clicked1(self):
        #self.socket_open_tcpc()

        account1 = self.user.text()
        password1 = self.passwd.text()
        test_str = 'event=login\naccount=' + account1 + '\npasswd=' + password1 + '\n'  # 暂定

        if DEBUG:
            input('传送账号密码到server')

        # 发送数据到服务器




import res_rc
