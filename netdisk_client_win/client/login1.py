# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'login.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import socket
from PyQt5 import QtCore, QtGui, QtWidgets
import threading
#import stopThreading
from PyQt5.QtWidgets import QMessageBox


DEBUG = 1
HOST = '192.168.42.230'
PORT = 4000
ADDR = (HOST, PORT)
ENCODING = 'gbk'
BUFFSIZE = 1024



def tcpClient():
    # 创建客户套接字
    with socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM) as s:
        # 尝试连接服务器
        s.connect(ADDR)
        print('连接服务成功！！')
        # 通信循环

        while True:
            input('pleace input something:')

            # 发送数据到服务器
            inData = '1'

            s.send(inData.encode(ENCODING))
            print('发送成功！')

            # 接收返回数据
            outData = s.recv(BUFFSIZE)
            print('返回数据信息：')
            print(format(outData))

        # 关闭客户端套接字
        s.close()
#test_str ="event=register\naccount=2205290\npasswd=1234456\n"



def socket_connect(self):
    self.s.connect(ADDR)
    print('已连接到服务器')

class Ui_LoginWin(object):
    def __init__(self):
        super(Ui_LoginWin, self).__init__()
        self.setupUi(self)
        self.s = None  # s代表socket，本文件中为tcp socket
        self.s_th = None  # s_th代表 thread
        self.client_th = None
        self.accept_th = None

        self.isLogin = 0
        self.isRegister = 0

        self.client_socket_list = list()
        self.link = False  # 初始化连接状态为False
        self.working = False  # 初始化工作状态为False

        #self.socket_open_tcpc()
        #self.login.clicked.connect(self.on_pushButton_login_clicked1)



    def setupUi(self, LoginWin):
        LoginWin.setObjectName("LoginWin")
        LoginWin.resize(701, 559)
        self.left = QtWidgets.QLabel(LoginWin)
        self.left.setGeometry(QtCore.QRect(90, 100, 231, 341))
        self.left.setStyleSheet("background-color: rgb(228, 255, 246);")
        self.left.setText("")
        self.left.setObjectName("left")
        self.right = QtWidgets.QLabel(LoginWin)
        self.right.setGeometry(QtCore.QRect(300, 100, 431, 341))
        self.right.setStyleSheet("background-image: url(:/images/2.jpg);")
        self.right.setObjectName("right")
        self.welcome = QtWidgets.QLabel(LoginWin)
        self.welcome.setGeometry(QtCore.QRect(120, 160, 151, 51))
        font = QtGui.QFont()
        font.setFamily("幼圆")
        font.setPointSize(20)
        self.welcome.setFont(font)
        self.welcome.setObjectName("welcome")
        self.user = QtWidgets.QLineEdit(LoginWin)
        self.user.setGeometry(QtCore.QRect(120, 240, 141, 21))
        self.user.setStyleSheet("border:none;\n"
"background-color: rgb(228, 255, 246);\n"
"border-bottom:2px solid rgba(0,0,0,100);")
        self.user.setObjectName("user")

        self.passwd = QtWidgets.QLineEdit(LoginWin)
        self.passwd.setGeometry(QtCore.QRect(120, 300, 141, 21))
        self.passwd.setStyleSheet("border:none;\n"
"background-color: rgb(228, 255, 246);\n"
"border-bottom:2px solid rgba(0,0,0,100);")
        self.passwd.setObjectName("passwd")

        #
        self.login = QtWidgets.QPushButton(LoginWin)
        self.login.setGeometry(QtCore.QRect(110, 370, 81, 41))
        self.login.setObjectName("login")

        #
        self.register_2 = QtWidgets.QPushButton(LoginWin)
        self.register_2.setGeometry(QtCore.QRect(200, 370, 81, 41))
        self.register_2.setObjectName("register_2")

        self.retranslateUi(LoginWin)
        QtCore.QMetaObject.connectSlotsByName(LoginWin)

######

##################




    def retranslateUi(self, LoginWin):
        _translate = QtCore.QCoreApplication.translate
        LoginWin.setWindowTitle(_translate("LoginWin", "Dialog"))
        self.right.setText(_translate("LoginWin", "TextLabel"))
        self.welcome.setText(_translate("LoginWin", "欢迎登录"))
        self.user.setPlaceholderText(_translate("LoginWin", "账号："))
        self.passwd.setPlaceholderText(_translate("LoginWin", "密码："))
        self.login.setText(_translate("LoginWin", "确定"))
        self.register_2.setText(_translate("LoginWin", "注册"))

        #self.socket_connect();




    '''def socket_open_tcpc(self):
        """
        软件作为tcp client模式连接到其他tcp server
        :return:
        """

        remote_ip = HOST
        remote_port = PORT
        ip_port = (remote_ip, int(remote_port))
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.s.connect(ip_port)
        except Exception as ret:
            print("Error:", ret)
            QMessageBox.critical(self, '错误', str(ret))
            self.socket_close()
        else:
            self.working = True
            self.link = True  # 设置连接状态标志位 True
            self.client_th = threading.Thread(
                target=self.tcp_client_concurrency)

            # 设置线程为守护线程，防止退出主线程时，子线程仍在运行
            self.client_th.setDaemon(True)
            self.client_th.start()
            connect_info = "已连接到服务器IP: %s 端口: %s\n" % ip_port
            print(connect_info)

    def tcp_client_concurrency(self):
        """
        TCP客户端创建子线程，防止主线程GUI为响应造成崩溃
        :return:
        """
        while True:
            try:
                """
                    针对服务器主动断开的异常处理
                """
                recv_msg = self.s.recv(BUFFSIZE)
            except Exception as ret:
                print("Error:", ret)
                # 这里不能用QMessageBox，会导致崩溃
                # QMessageBox.critical(self, '错误', str(ret))
                self.socket_close()

            else:
                if recv_msg:
                    print(recv_msg)
                    if 'accepted' in recv_msg.decode():
                        self.isLogin = 1
                    if 'failed' in recv_msg.decode():
                        self.isLogin = 0
                    if 'accepted2' in recv_msg.decode():
                        self.isRegister = 1
                    if 'failed2' in recv_msg.decode():
                        self.isLogin = 0
                else:
                    self.s.close()
                    msg = '连接已断开\n'
                    #self.signal_write_msg.emit(msg)
                    self.working = False
                    self.socket_close()
                    break

    def socket_close(self):
        """
        关闭TCP网络的方法
        :return:
        """


        try:
            self.s.close()
            self.working = False
            #self.open_btn.setEnabled(True)
            print('TCP connection closed...')
        except Exception as ret:
            pass

        try:
            # 关闭线程
            stopThreading.stop_thread(self.s_th)
            self.link = False
        except Exception:
            pass
        try:
            # 关闭线程
            stopThreading.stop_thread(self.client_th)
            self.link = False
        except Exception:
            pass


    def data_send_t_c(self,message):
        """
        功能函数，用于TCP客户端和TCP服务器发送消息
        :return: None
        """
        if self.working is False:
            QMessageBox.critical(self, '警告', '请先设置TCP网络')
        else:
            if self.link:
                send_msg = message # 从发送区获取数据
                # 判断附加为功能是否勾选并进行后续处理

                print(send_msg)
                if message != '':
                    try:
                        self.s.send(send_msg.encode(ENCODING))
                        #self.tx_count += len(send_msg)
                        #self.statusbar_dict['tx'].setText(
                           # '发送计数：%s' % self.tx_count)
                    except Exception as ret:
                        pass
                else:
                    QMessageBox.critical(self, '警告', '发送不可为空')
            else:
                QMessageBox.critical(self, '警告', '当前无任何连接')



    def file_send_t_c(self):
        """
        功能函数，用于TCP客户端和TCP服务器发送文件
        :return: None
        """
        if self.working is False:
            QMessageBox.critical(self, '警告', '请先设置TCP网络')
        else:
            if self.link:
                if self.file_load.isChecked():
                    send_msg = self.f_data
                else:
                    send_msg = b''
                print(send_msg, len(send_msg))
                if send_msg != b'':
                    self.s.send(send_msg)
                else:
                    QMessageBox.critical(self, '警告', '发送不可为空')
                self.tx_count += len(send_msg)
                self.statusbar_dict['tx'].setText('发送计数：%s' % self.tx_count)
            else:
                QMessageBox.critical(self, '警告', '当前无任何连接')





        # 发送数据到服务器

    def socket_login_recv(self):
        str = self.s.recv(BUFFSIZE).decode()
        return str'''




import res_rc
